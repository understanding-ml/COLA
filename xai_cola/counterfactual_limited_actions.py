import string
import numpy as np
import pandas as pd
import copy
from IPython.display import clear_output
from xai_cola.data_interface import BaseData
from xai_cola.ml_model_interface import Model

from xai_cola.cola_policy.matching import CounterfactualOptimalTransportPolicy, CounterfactualCoarsenedExactMatchingOTPolicy, CounterfactualNearestNeighborMatchingPolicy, CounterfactualExactMatchingPolicy
from xai_cola.cola_policy.data_composer import DataComposer
from xai_cola.cola_policy.feature_attributor import Attributor, PSHAP
from xai_cola.plot.highlight_dataframe import highlight_differences
from xai_cola.plot.heatmap import heatmap_massivedata

class COLA:
    """This class is used for creating COLA(COunterfactual with Limited Actions).

    Parameters:
        data: Use data_interface to wrapper your data (Here we need the columns name and target name of your dataset, so we use the wrappered data)
        ml_model: Your pre-trained model, used for prediction. And it should be wrapped in our BaseModel.
        x_factual: The factual instance for which you want to generate counterfactuals. It should be a numpy array.
        x_counterfacutal: The generated counterfactuals(either generated from our provided explainer, or generated by yourself). It should be a numpy array.
    """
    def __init__(
            self, 
            data:BaseData,
            ml_model: Model,
            x_factual: np = None, 
            x_counterfactual: np = None,
            ):
        self.data = data
        self.ml_model = ml_model
        self.x_factual = x_factual
        self.x_counterfactual = x_counterfactual
        self.row_indices = None
        self.col_indices = None


    """Set the policy for the COLA

    Parameters:
        matcher: The matcher between factual and counterfactual, it can be "ot": Optimal Transport or "Ect": Exact Match, "nn":nearest neighbor, "cem":coarsened exact matching(cem can't be used right now) etc.
        attributor:  The default attributor is "pshap"- shapley value with joint probability.
        Avalues_method: The method to choose the value of q
    """
    def set_policy(
            self,
            matcher: string = "ot", 
            attributor: string = "pshap",
            Avalues_method: string = "max",
            prob_matrix = None # prob_matrix is used for ect matcher, maybe we need it in the future renew
            ):
        self.matcher = matcher
        self.attributor = attributor
        self.Avalues_method = Avalues_method
        # self.prob_matrix = prob_matrix
        if matcher == "ot":
            matcher_name = "Optimal Transport Matching"
        elif matcher == "cem":
            matcher_name = "Coarsened Exact Matching"
            raise ValueError(f"{matcher_name} can't be used right now, please choose another matcher, like 'ot' or 'nn'!")
        elif matcher == "nn":
            matcher_name = "Nearest Neighbor Matching"
        elif matcher == "ect":        # Right now, ect matcher can only be used in n rows factual instances with n rows counterfactual instances indices corresponding to each other.
            matcher_name = "Exact Matching"
        print(f"You choose the Policy: {attributor} With {matcher_name}, Avalues_method is {Avalues_method}")
    

    """Get the counterfactual with limited actions
    Parameters:
    limited_actions: The number of actions you want to limit to.

    Returns: factual_with_target(dataframe), all_counterfactuals_with_target(dataframe), actionlimited_counterfactuals_with_target(dataframe)
    """
    def get_refined_counterfactual(self, limited_actions):
        varphi = self._get_attributor()
        q = self._get_data_composer()
        self.limited_actions = limited_actions

        # 1. Find the top 'action' highest probability values and their positions in the varphi matrix
        flat_indices = np.argpartition(varphi.flatten(), -self.limited_actions)[-self.limited_actions:]
        row_indices, col_indices = np.unravel_index(flat_indices, varphi.shape)
        
        # store the row and column indices
        self.row_indices = row_indices
        self.col_indices = col_indices

        # 2. Find the values at these positions in q
        q_values = q[row_indices, col_indices]
        # 3. Replace the corresponding values in x_factual with the values found in q
        x_action_constrained = self.x_factual.copy()
        # 4. get the action-constrained CE
        for row_idx, col_idx, q_val in zip(row_indices, col_indices, q_values):
            x_action_constrained[row_idx, col_idx] = q_val

        """get the corresponding_counterfacutal of the factual instance(processed by the matcher) 

        -----------------------------------------
        What's the corresponding_counterfactual?
        -----------------------------------------
        Answer:
        The difference between counterfactual and corresponding_counterfactual is that the corresponding_counterfactual is processed by the matcher.
        which means that each row in counterfactual is one-to-one correspondence to each row in a factual instance
        
        if we have n row factual instances and 2n rows counterfactual instances,
        after the matcher, we will choose from 2n rows couterfactual instances, and then get n rows corresponding_counterfactual instances.
        """    
        corresponding_counterfactual = q

        # 5. get the prediction
        y_factual = self.ml_model.predict(self.x_factual)
        y_counterfactual = self.ml_model.predict(self.x_counterfactual)
        y_counterfactual_limited_actions = self.ml_model.predict(x_action_constrained)
        y_corresponding_counterfactual = self.ml_model.predict(corresponding_counterfactual)

        # 6. return the dataframes
        self.factual_dataframe = None
        self.ce_dataframe = None
        self.ace_dataframe = None
        self.corresponding_counterfactual_dataframe = None
        self.factual_dataframe = self.return_dataframe(self.x_factual, y_factual)
        self.ce_dataframe = self.return_dataframe(self.x_counterfactual, y_counterfactual)
        self.ace_dataframe = self.return_dataframe(x_action_constrained, y_counterfactual_limited_actions)
        self.corresponding_counterfactual_dataframe = self.return_dataframe(corresponding_counterfactual, y_corresponding_counterfactual)
        # apply the same data type as the original data
        for col in self.ce_dataframe.columns:
            self.corresponding_counterfactual_dataframe[col] = self.corresponding_counterfactual_dataframe[col].astype(self.ce_dataframe[col].dtype)

        return self.factual_dataframe, self.ce_dataframe, self.ace_dataframe

    """Highlight the changes from factual to corresponding_counterfactual, and from factual to actionlimited_counterfactuals
    
    Returns: factual_with_target(dataframe), corresponding_counterfactual_with_target(dataframe, with changes highlighted), actionlimited_counterfactuals_with_target(dataframe, with changes highlighted)
    """
    def highlight_changes(self):
        """ highlight the changes from factual to ace """
        self.factual_dataframe = self.factual_dataframe.astype(object)
        self.ace_dataframe = self.ace_dataframe.astype(object)
        self.corresponding_counterfactual_dataframe = self.corresponding_counterfactual_dataframe.astype(object)
        
        # preparation for the highlight
        cce_df = self._change_df_value(self.factual_dataframe, self.corresponding_counterfactual_dataframe)
        ace_df = self._change_df_value(self.factual_dataframe, self.ace_dataframe)

        cce_style = cce_df.style.apply(lambda x: highlight_differences(x, self.factual_dataframe, cce_df, self.data.get_target_name()), axis=None)
        cce_style = cce_style.set_properties(**{'text-align': 'center'})

        ace_style = ace_df.style.apply(lambda x: highlight_differences(x, self.factual_dataframe, ace_df, self.data.get_target_name()), axis=None)
        ace_style = ace_style.set_properties(**{'text-align': 'center'})
        return self.factual_dataframe, cce_style, ace_style


    """The following code is used for generating heatmap for massivedata (with too many rows or columns)
    Returns: The heatmap plot for changes from factual to counterfactual
    """
    def heatmap(self):
        print("changes from factual to counterfactual")
        plot1 = heatmap_massivedata(self.factual_dataframe, self.corresponding_counterfactual_dataframe, self.data.get_target_name())
        print("changes from factual to actionlimited_counterfactuals")
        plot2 = heatmap_massivedata(self.factual_dataframe, self.ace_dataframe, self.data.get_target_name())
        return plot1, plot2


    def _get_matcher(self):
        if self.matcher == "ot":
            joint_prob = CounterfactualOptimalTransportPolicy(self.x_factual, self.x_counterfactual).compute_prob_matrix_of_factual_and_counterfactual()
            return joint_prob
        elif self.matcher == "cem":
            joint_prob = CounterfactualCoarsenedExactMatchingOTPolicy(self.x_factual, self.x_counterfactual).compute_prob_matrix_of_factual_and_counterfactual()
            return joint_prob
        elif self.matcher == "nn":
            joint_prob = CounterfactualNearestNeighborMatchingPolicy(self.x_factual, self.x_counterfactual).compute_prob_matrix_of_factual_and_counterfactual()
            return joint_prob
        elif self.matcher == "ect":
            joint_prob = CounterfactualExactMatchingPolicy(self.x_factual, self.x_counterfactual, prob_matrix=None).compute_prob_matrix_of_factual_and_counterfactual()
            return joint_prob

    def _get_attributor(self):
        if self.attributor == "pshap":
            varphi = PSHAP(
                ml_model=self.ml_model, 
                x_factual=self.x_factual, 
                x_counterfactual=self.x_counterfactual, 
                joint_prob=self._get_matcher()
                ).calculate_varphi()
            return varphi
        elif self.attributor == "randomshap":
            pass

    def _get_data_composer(self):
        q = DataComposer(x_counterfactual=self.x_counterfactual, joint_prob=self._get_matcher(), method=self.Avalues_method).calculate_q()
        return q

    def return_dataframe(self, x, y):
        df = pd.DataFrame(x)
        df.columns = self.data.get_x_labels()
        df[self.data.get_target_name()] = y 
        df.style.set_properties(**{'text-align': 'center'})
        return df
    
    def _change_df_value(self, factual, ce):
        for row in range(ce.shape[0]):
            for col in range(ce.shape[1]):
                val_factual = factual.iat[row, col]
                val_ce = ce.iat[row, col]
                if val_factual != val_ce:
                    ce.iat[row, col] = f'{val_factual} -> {val_ce}'
        return ce
    
    def query_minimum_actions(self):
        self.varphi = self._get_attributor()
        self.q = self._get_data_composer()
        m, y_corresponding_counterfactual = self._find_changes_m_of_ce()
        
        low, high = 1, m
        while low < high:
            mid = (low + high) // 2
            diff = self._compare_target_ce_to_ace(mid, y_corresponding_counterfactual, self.varphi, self.q)
            if diff != 0:
                while diff != 0:
                    mid = mid + diff
                    diff = self._compare_target_ce_to_ace(mid, y_corresponding_counterfactual, self.varphi, self.q)
                break
            else:
                high = mid
                    
        clear_output(wait=True)
        print(f"The minimum number of actions is {mid}")
        return mid

    def _compare_target_ce_to_ace(self, mid, y_corresponding_counterfactual, varphi, q):
        self.limited_actions = mid

        # 1. Find the top 'action' highest probability values and their positions in the varphi matrix
        flat_indices = np.argpartition(varphi.flatten(), -self.limited_actions)[-self.limited_actions:]
        row_indices, col_indices = np.unravel_index(flat_indices, varphi.shape)
        
        # # store the row and column indices
        # self.row_indices = row_indices
        # self.col_indices = col_indices

        # 2. Find the values at these positions in q
        q_values = q[row_indices, col_indices]
        # 3. Replace the corresponding values in x_factual with the values found in q
        x_action_constrained = self.x_factual.copy()
        
        # 4. get the action-constrained CE
        for row_idx, col_idx, q_val in zip(row_indices, col_indices, q_values):
            x_action_constrained[row_idx, col_idx] = q_val
        # corresponding_counterfactual = q

        # 5. get the prediction
        # y_factual = self.ml_model.predict(self.x_factual)
        y_counterfactual_limited_actions = self.ml_model.predict(x_action_constrained)
        # y_corresponding_counterfactual = self.ml_model.predict(corresponding_counterfactual)
        
        result = np.sum(y_counterfactual_limited_actions != y_corresponding_counterfactual)
        return result

    def _find_changes_m_of_ce(self):
        corresponding_counterfactual = self._get_data_composer()
        y_corresponding_counterfactual = self.ml_model.predict(corresponding_counterfactual)
        # Count the number of differing elements
        m = np.sum(corresponding_counterfactual != self.x_factual)
        return m, y_corresponding_counterfactual